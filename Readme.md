# Vonage Cloud Runtime -  Messages API - Rate Limit Extender & Queueing

This is an application built on Vonage Cloud runtime that will offer an API endpoint that takes in requests for Messages API and queues them up with the help of the Vonage Cloud Runtime. The benefit is that you can send messages at a rate of up to 2000 api requests/messages per second out of the box. The service will then queue it up for Vonage Messages API, which has a default rate limit of 40 api request/messages per second. You will not need to throttle your api requests anymore, even for larger campaigns.

To send messages to this instance, you will need to use the instance url under API endpoint /enqueue and your typical payload for Vonage Messages API. That means if you use Messages API today, all you need to do is to deploy this application and then change the API url you are sending messages to to this instance. Nothing else needs changing.

## General Instrutions

This Code can be on-lcikc deployed into your Vonage Account from its [Vonage Code Hub Page](https://developer.vonage.com/en/cloud-runtime/b395d1fe-8c70-4c9b-a6c8-d477e07f74ab_messages-api-rate-limit-extender-queueing).

However, if you intend to deploy this yourself, please follow the guides here below.

## Requirements
- You must have a [Vonage Developer Account](https://developer.vonage.com/)
- You must have the [Vonage Cloud Runtime CLI](https://developer.vonage.com/en/vonage-cloud-runtime/getting-started/working-locally) installed and configured

## Run Debug

To get started in debug:

1. Run `nvm use` or use node version 22.
2. Run `npm i` to install packages.
3. Edit vcr.yml and paste your own application-id for both instance and debug mode. They should be different app ids. You can create them via the [Vonage Application Dashboard](https://dashboard.nexmo.com/applications/new) or by running `vcr app create --name 'my-app-name'`.
4. Run `vcr debug` to start live debug mode. Use the url displayed in the terminal for debugging.

## Deploy

1. Follow the [Run Debug](#run-debug) steps 1. to 3. before you continue.
2. Run `vcr deploy` to deploy the app and get your instance url.

## API Endpoint

To send messages, use the following API endpoint that this app exposes. The authentication and body of the messages should be exactly the same as the one for Messages API.

### POST https://{YOUR-INSTANCE-NAME}.euw1.runtime.vonage.cloud/enqueue

#### Request:

Header & Body must follow the [Vonage Messages API REST Reference](https://developer.vonage.com/en/api/messages). The following are examples for an SMS and RCS message bodies.

SMS Body:
```
{
    "message_type": "text",
    "text": "Vonage is the best SMS and RCS provider.",
    "to": "4915112345678",
    "from": "Vonage",
    "channel": "sms"
}
```

RCS Body:
```
{
    "message_type": "text",
    "text": "Vonage is the best SMS and RCS provider.",
    "to": "4915112345678",
    "from": "YourVonageRcsSenderId",
    "channel": "rcs"
}
```

#### Response:

**IMPORTANT:** Since we are adding the messages to a queue before sending them thorugh VOnage Messages API, we will not receive a `message_uuid` when making the API call. Instead, we are receiving a `temporaryMessageUuid` generated by the application. This temporary message uuid will also be added as a `client_ref` parameter to the messages API call, meaning you will find the temporary message uuid later in all reports and webhooks in the `client_ref` field. This might change the logic of your application, if you are depending on the `message_uuid` to match webhooks for message status to your sent messages. If you set a `client_ref` field yourself, this will be taken and responded back with as `temporaryMessageUuid`.

STATUS: 200
```
{
    "temporaryMessageUuid": "a1b1c1d1-a1a1-a1a1-a1a1-a1b1c1d1e1f1"
}
```

For other response statuses see Vonage Messages API Reference linked above.